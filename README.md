# 3813ICT_Assignment_Part1
Author: Connor Aitken s5181649

## Organization of the Git Repository
For the purpose of this assessment the git repository was organized by creating to 2 branches. The first, main branch, was pushed a functioning state of the project at every major milestone of the development, for e.g., when the all components related to the Group Admin's abilities were completed. The second, working branch, was used as the current branch being worked upon. It would be pushed to more frequently, at the completion of any component and at the end of every coding session, along with a commit message indicating the progression of the development thus far.

## Data Structures
The data for Assignment Part1 is kept in a series of '.json' files, the main three of which are; `users.json`, `groups.json` and `rooms.json`.

`users.json` holds all the user data including a username, email and role. Here is an example: `{"id":0,"uname":"super","email":"super@gmail.com","role":"SuperAdmin","valid":false}`

`groups.json` holds a list of all the groups, their group id, name, number of rooms in the group, and the number of users belonging to the group. Here is an example: `{"id":0,"name":"Group1","numOfRooms":1,"numOfUsers":4}`

`rooms.json` holds a list of all the rooms, which includes the groupID of the group they belong to, a roomID and room name to identify themselves and the number of users belonging to the room. Here is an example: `{"groupID":0,"roomID":0,"name":"room1","numOfUsers":5}`

There is also two folders containing more data, a `groups` folder with a file for each existing group filled with a list of every user belonging to the group and what rooms they have access to, and also a `assignments` folder with a file for every room, saved as `{{groupID}}-{{roomID}}.json`, with a list of users that can access that room.

Admittingly I don't believe this to be the best data layout, there is a bit of data overlap and repetition, and it certainly caused a headache to work with at times, but with the implementation of the database in the next task most of this should be tidied up.

## Node Server Architecture - REST API
The node server handles all the interaction with the data and is designed to handle most of the proccessing on its end and leave the Angular/Client side to deal with just obtaining the input variables and displaying the returned data. To do so a series of routes, 13 in total, were created, each handling a unique tasks and designed to be easily reusable. The routes make use of three models to stay consistant, in particular with creating new entries of data, they are a `User` model, `Group` model and `Room` model which are representative of their respective .json files. Below is a list and description of each route:

1. `create_group` - Parameters: groupName; Returns: {"saved": true/false}; 
Description: This route takes a string which represents the name of a new group to be created, reads in the data from the `groups.json` file, appends the new group to the data and then writes the new data back to the `groups.json` file. It returns {"saved": false} if an error occurs or {"saved": true} if everything runs smoothly.
2. `create_room` - Parameters: groupID, roomName; Returns: {"saved": true/false, "exists": true/false}; 
Description: This route takes an integer of the ID corresponding to the group the room is to be created in and a string which represents the name of a new room to be created. It reads in the data from the `rooms.json` file, checks to see if a room already exists with that name in the group, if there is not it appends the new room to the data and then writes the new data back to the `rooms.json` file, as well creates a file in the `assignments` folder to represent the new room. If the is a room with the same name in the group already it returns {"saved": false, "exists": true} telling the user the room already exists, otherwise it returns {"saved": false, "exists": false} if an error occurs or {"saved": true, "exists": false} if everything runs smoothly.
3. `create_user` - Parameters: userName, email, role; Returns: {"success": true/false, "exists": true/false}; 
Description: This route takes 3 strings, representing a new users username, email and role. It reads in the data from the `users.json` file, checks to see if a user already exists with that username, if there is not one it appends the new user to the data and then writes the new data back to the `users.json` file. If the is a user with the same username already it returns {"success": false, "exists": true} telling the user the username already exists, otherwise it returns {"success": false, "exists": false} if an error occurs or {"success": true, "exists": false} if everything runs smoothly.
4. `invite_users` - Parameters: groupID, groupName, roomName, userName; Returns: {"success": true/false, "exists": true/false}; 
Description: This route takes 3 strings, representing the name of the group which holds the room the user is being added to, the room name of said room and the username of the user to be added, and an integer, an ID corresponding to the group. It reads in the data from the `users.json` file, `rooms.json` file, `assignments/{{groupID}}-{{roomID}}.json` file and `groups/{{groupName}}.json` file. It creates and adds a new user with the pasased username to the user data if it doesn't already exists otherwise loads the user data for the user with the same username, adds the user to the file for the room in the assignments folder, increments the number of users count in the rooms data and adds the user to the file in the groups folder. It then writes any changes back into the corresponding files. It returns {"success": false, "exists": true} if the user already has access to the room, {"success": false, "exists": false} if an error occurs or {"success": true, "exists": false} if everything runs smoothly.
5. `load_group_info` - Parameters: id; Returns: groupRooms; 
Description: This route takes an integer representing a the ID of a group, reads in the data from the `rooms.json` file, appends all the rooms with a matching groupID to a list and then returns the list to the user.
6. `load_group_users` - Parameters: Group Object; Returns: groupUsrs; 
Description: This route takes a group object from the `groups.json` file, reads in the `groups/{{groupName}}.json` file and returns a list of users found in the group and what rooms that have access to.
7. `load_group` - Parameters: NULL; Returns: groupsArray; 
Description: This route takes in no input, reads the data from the `groups.json` file and returns the list groups.
8. `login` - Parameters: uname; Returns: newUser; 
Description: This route takes in a string that represents the username of the user that whishes to login, it reads the data from the `users.json` file, compares the username to the usernames of all the users in the user data. If a match is found the users valid attribute is set to true and the user's full details are returned, if a match is not found a blank user with just the entered username and the valid attribute set to false is returned.
9. `remove_group` - Parameters: groupName; Returns: {"removed": true/false}; 
Description: This route takes in a string that represents the name of the group to be removed. It reads the data from the `groups.json` file, compares the groupName to the groupNames of all the groups in the group data. If a match is found the entry is deleted, the change is written back to the `groups.json` file and {"removed": true} is returned. If a match is not found or an error occurs res.send({"removed": false}) is returned.
10. `remove_room` - Parameters: groupID, name; Returns: {"removed": true/false}; 
Description: This route takes in an interger, representing the ID of the group in which the room we want to delete resides, and a string, that represents the name of the room to be removed. It reads the data from the `rooms.json` file, compares the groupID and the roomName to the entries in the rooms data. If a match is found the entry is deleted, the change is written back to the `rooms.json` file, the `assignments/{{groupID}}-{{roomID}}.json` file linked to the room is deleted and {"removed": true} is returned. If a match is not found or an error occurs res.send({"removed": false}) is returned.
11. `remove_users` - Parameters: groupID, roomName, userName; Returns: {"success": true/false, "exists": true/false}; 
Description: This route takes in an interger, representing the ID of the group in which the room we want to remove a users access to resides, and two strings, one for the name of the room and one for the username of the user to remove from the room. It reads the data from the `rooms.json` file, checks to see if the room we want to remove the user from exists, if it does then the room's file from the assignments folder is read in. The username of the user to be removed is then search for within the room's file, if found the user is removed, the number of users count for the room is decremented in the room data and the changes are written back into the respective files. If a username match is not found {"success": false, "exists": false} is returned, if an error occurs {"success": false, "exists": true} is returned or if everything runs smoothly {"success": true, "exists": true} is returned.
12. `upgrade_to_ass` - Parameters: uname; Returns: {"success": true/false, "exists": true/false}; 
Description: This route takes in a string, representing the username of the user we wish to upgrade to the role of Group Assistant. It reads the data from the `users.json` file, compares the given username to all the usernames in the user data. If a match is found a check is run to make sure the user is only a standard user before hand and does not already have a special role, if they do not their role is changed to GroupAssis and the change is written to the `users.json` file. If a match is not found {"success": false, "exists": false} is returned, if an error occurs {"success": false, "exists": true} is returned or if everything runs smoothly {"success": true, "exists": true} is returned.
13. `upgrade_user` - Parameters: userName, role; Returns: {"success": true/false, "exists": true/false}; 
Description: This route takes in two strings, one for the username of the user to upgrade and one for the new role to upgrade the user to. It reads the data from the `users.json` file, compares the given username to all the usernames in the user data. If a match is found a check is run to see if the new role is SuperAdmin that the user doesn't already have that role, if not the user's role is updated and the change is written to the `users.json` file. If the new role is GroupAdmin a check is made to see that the user doesn't already have that role or is a SuperAdmin in which case the role is updated and the change is written to the `users.json` file. If a match is not found {"success": false, "exists": false} is returned, if the user already has the role or a higher one or if an error occurs {"success": false, "exists": true} is returned or if everything runs smoothly {"success": true, "exists": true} is returned.

## Angular Architecture 
For the Angular/Client side of the application all the pages of the web app were separated into their own component, totalling in 6 components. The main use of the components is to retrive input from the user, send the input to the appropriate routes on the server and then display the returned values. For Part1 no services or models were utilised. Below is a list of the components and a description of them:

1. `group-admin` : This component gives Super Admins and Group Admins the ability to create new groups, remove groups and navigate to the group-management component. 
2. `group-assis` : This component gives Group Assisstants the ability create new rooms/channels in a group and to select users that already exist within the group then add or remove them from rooms in the group.
3. `groups` : This component is the main page of the app, it displays all the groups the user is a part of, and once a group is selected all the rooms in the group and users with access to the rooms are displayed. It also will have a button for the user to access any abilities corresponding to the users role. Eventually this will also be where the users can chat to each other inside the rooms.
4. `group-management` : This component gives Super Admins and Group Admins the ability to create or remove rooms/channels, invite any user to any room or remove and existing user from a room, and finally upgrade any standard user to a Group Assisstant.
5. `login` : This component prompts the user to enter their username with is then authenticated and if successful the user's details are saved into localstorage.
6. `super-admin` : This component gives Super Admins the ability to create new users, upgrade users to Super Admin or Group Admin and navigate to the group-admin component.